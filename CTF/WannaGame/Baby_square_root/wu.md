# Baby Square Root
```
from Crypto.Util.number import bytes_to_long, getPrime
from secret import flag

m = bytes_to_long(flag)

def genkey(nbits):
    while True:
        p, q, r = [getPrime(nbits) for _ in range(3)]
        if (p % 4 == 3) and (q % 4 == 3) and (r % 4 == 3):
            if (m % p)**2 > p and (m % p)**2 > q and (m % r)**2 > r:
                return p, q, r

p, q, r = genkey(256)
print("p = %d" % p)
print("q = %d" % q)
print("r = %d" % r)        
n = p * q * r
assert m * m > n
c = pow(m, 2, n)
print("c = %d" % c)
# p = 70983802669936779583888271861264418553792693554114299680738628616089490185419
# q = 58305592279975890783353046164122693676607057964958376141731197322666598532103
# r = 97916428487890361773100867250333330323792113286852927362830936108809145675571
# c = 133577637589652723069183361093768415945855108781724437021455876659182394384174818367149957719648205506911291215264096735072761818791817528925431287027255773272638623023278085524784625145794560351502585907066260712268740708335604444

```

**Nhận xét:**
- Đây là 1 bài Rabin RSA
- Cả 3 số nguyên tố đều = 3 (mod 4)
- Khi Legendre Symbol (x/N) = 1 thì x và N-x là 1 square modulo N

**Tiếp cận**
- mp = c^(p+1)/4 (mod p) => mp^2 = c (mod p)
- mq = c^(q+1)/4 (mod q) => mq^2 = c (mod q)
- mr = c^(r+1)/4 (mod r) => mr^2 = c (mod r)
- Từ 3 gạch đầu dòng trên, ta dùng CRT để tính toán ra lại giá trị m.

**SOLVE**
```
from Crypto.Util.number import *
import gmpy2

p = 70983802669936779583888271861264418553792693554114299680738628616089490185419
q = 58305592279975890783353046164122693676607057964958376141731197322666598532103
r = 97916428487890361773100867250333330323792113286852927362830936108809145675571
c = 133577637589652723069183361093768415945855108781724437021455876659182394384174818367149957719648205506911291215264096735072761818791817528925431287027255773272638623023278085524784625145794560351502585907066260712268740708335604444
n = p * q * r

mp = pow(c, (p+1)//4, p)
mq = pow(c, (q+1)//4, q)
mr = pow(c, (r+1)//4, r)

print("mp = ", mp)
print("mq = ", mq)
print("mr = ", mr)

print(pow(mp, 2, p) == c%p)

yp = n//mq//mr
yq = n//mp//mr
yr = n//mp//mq

zp = inverse(yp, p)
zq = inverse(yq, q)
zr = inverse(yr, r)

m = (mp*yp*zp + mq*yq*zq + mr*yr*zr) 
m = 405251878563859034013993263635104394619048731139877286040011778613066766304610456261463756664887516315281979277436649271325146838356345161228881883353921803425724176576610588194813849282591846167918210163694920450096777213599649434
print(long_to_bytes(n - m))
```

**NOTE**: vì như đã nói ở trên, hoặc là m, hoặc là n-m nên thử cả 2, cái nào được là flag :D